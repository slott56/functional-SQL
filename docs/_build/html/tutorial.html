<!DOCTYPE html>

<html lang="en" data-content_root="./">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="viewport" content="width=device-width, initial-scale=1" />

    <title>Tutorial &#8212; Functional SQL  documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=d1102ebc" />
    <link rel="stylesheet" type="text/css" href="_static/alabaster.css?v=12dfc556" />
    <script src="_static/documentation_options.js?v=5929fcd5"></script>
    <script src="_static/doctools.js?v=9a2dae69"></script>
    <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Demonstration Code" href="demo.html" />
    <link rel="prev" title="Concept" href="concept.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
  

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <section id="tutorial">
<span id="id1"></span><h1>Tutorial<a class="headerlink" href="#tutorial" title="Link to this heading">¶</a></h1>
<p>There are several parts to this tutorial:</p>
<ol class="arabic simple">
<li><p><a class="reference internal" href="#queries">Queries</a></p></li>
<li><p><a class="reference internal" href="#schema-and-tables">Schema and Tables</a></p></li>
<li><p><a class="reference internal" href="#with-clause-and-recursion">WITH clause and Recursion</a></p></li>
</ol>
<p>A more complete example is in <a class="reference internal" href="demo.html#demo"><span class="std std-ref">Demonstration Code</span></a>.</p>
<section id="queries">
<h2>Queries<a class="headerlink" href="#queries" title="Link to this heading">¶</a></h2>
<p>The essential SQL query has a number of clauses.
Here’s a short example of a <code class="docutils literal notranslate"><span class="pre">SELECT</span></code>:</p>
<div class="highlight-SQL notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">name</span><span class="p">,</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">c2</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">names_table</span><span class="w"> </span><span class="n">n</span><span class="p">,</span><span class="w"> </span><span class="n">values_table</span><span class="w"> </span><span class="n">v</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">n</span><span class="p">.</span><span class="n">code</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">v</span><span class="p">.</span><span class="n">c1</span>
</pre></div>
</div>
<p>We rewrite this into a Python <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> object.
Each clause has unique rewrite rules, depending con what the SQL clause does.</p>
<ol class="arabic">
<li><p><code class="docutils literal notranslate"><span class="pre">SELECT</span></code>. Each variable or expression must becomes a lambda object, to be computed later.
A target variable must be provided; this is in effect, a mandatory <code class="docutils literal notranslate"><span class="pre">AS</span></code> clause.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="n">Select</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">cr</span></code> parameter is a reminder that the lambda will be evaluated with a “composite row”.
This row has the tables named in the from clause and the columns of those tables.
The <code class="docutils literal notranslate"><span class="pre">cr.n.name</span></code> expression picks the table named <code class="docutils literal notranslate"><span class="pre">n</span></code> and the column <code class="docutils literal notranslate"><span class="pre">name</span></code> from that table.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">FROM</span></code>. Each table name is replaced by a <code class="docutils literal notranslate"><span class="pre">Table</span></code> object. We’ll see how these are made in the <a class="reference internal" href="#schema-and-tables">Schema and Tables</a> section.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">names_table</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">values_table</span><span class="p">)</span>
</pre></div>
</div>
<p>As with the <code class="docutils literal notranslate"><span class="pre">SELECT</span></code> clause, this provides the alias name and the table name.
Table names can be listed without alias names, also.
The tables must be loaded <em>before</em> building the query.</p>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">WHERE</span></code>. The logical condition becomes a lambda, also.</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">cr</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
</pre></div>
</div>
</li>
</ol>
<p>The <code class="docutils literal notranslate"><span class="pre">.from_()</span></code> and <code class="docutils literal notranslate"><span class="pre">.where()</span></code> syntax are methods to add details to the <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> object.
There are other methods include <code class="docutils literal notranslate"><span class="pre">.group_by()</span></code> and <code class="docutils literal notranslate"><span class="pre">.having()</span></code>.</p>
<p>Generally, the whole thing must either be complete on one line, or wrapped in <code class="docutils literal notranslate"><span class="pre">()</span></code>‘s.
This seems best:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">query</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Select</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">c2</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">names_table</span><span class="p">,</span> <span class="n">v</span><span class="o">=</span><span class="n">values_table</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">n</span><span class="o">.</span><span class="n">code</span> <span class="o">==</span> <span class="n">cr</span><span class="o">.</span><span class="n">v</span><span class="o">.</span><span class="n">c1</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Using wrapping <code class="docutils literal notranslate"><span class="pre">()</span></code>‘s makes the query object easier to work with.</p>
<p>We call the <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> a “Query Builder”.
It doesn’t “do” anything.
It barely has any internal state changes.
It collects the various clauses an options of a query.</p>
<p>A separate <a class="reference internal" href="funcsql.html#funcsql.fetch" title="funcsql.fetch"><code class="xref py py-func docutils literal notranslate"><span class="pre">funcsql.fetch()</span></code></a> function uses a query object to process data defined in <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> objects.</p>
</section>
<section id="schema-and-tables">
<h2>Schema and Tables<a class="headerlink" href="#schema-and-tables" title="Link to this heading">¶</a></h2>
<p>A <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> object has a name and a list of rows.
The list of rows need to be dictionary objects.
The keys of this dictionary are the column names.</p>
<p>We limit column names to valid Python identifiers.
After all, this is pure Python code.
Python identifiers, for example, are case sensitive, where in SQL, there’s no such rule.</p>
<p>How this data arrives on the scene is left wide open.
For one example, consider a CSV-format file with a bunch of columns.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">csv</span> <span class="kn">import</span> <span class="n">DictReader</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">table_1_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;table_1.csv&quot;</span><span class="p">)</span>
<span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">table_1_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">source_file</span><span class="p">:</span>
    <span class="n">rdr</span> <span class="o">=</span> <span class="n">DictReader</span><span class="p">(</span><span class="n">source_file</span><span class="p">)</span>
    <span class="n">table_1</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;table_1&quot;</span><span class="p">,</span> <span class="nb">list</span><span class="p">(</span><span class="n">rdr</span><span class="p">))</span>
</pre></div>
</div>
<p>There’s no formal SQL-schema with table definitions.
The table is defined by the column names.
The column names in the CSV file need to match the column names in the <code class="docutils literal notranslate"><span class="pre">query</span></code> object.</p>
<p>That’s the only rule:</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>Any source of <code class="docutils literal notranslate"><span class="pre">list[dict[str,</span> <span class="pre">Any]]</span></code> data can build a <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> object.</p>
</div>
<p>Also important, the <a class="reference internal" href="funcsql.html#funcsql.Row" title="funcsql.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Row</span></code></a> objects will be created for you as needed.
Do not map source data to <a class="reference internal" href="funcsql.html#funcsql.Row" title="funcsql.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Row</span></code></a> instances.</p>
<p>Here are two other examples of tables:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">values_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;values_table&quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;c1&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">:</span> <span class="mf">42.0</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;c1&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">:</span> <span class="mf">3.14</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;c1&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;c2&quot;</span><span class="p">:</span> <span class="mf">2.72</span><span class="p">},</span>
    <span class="p">],</span>
<span class="p">)</span>
<span class="n">names_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;names_table&quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Life&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Pi&quot;</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;code&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Ee&quot;</span><span class="p">},</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
<p>And, yes, the table name matches the variable name to which the <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> object is assigned.
This isn’t a requirement, but debugging can be a nightmare if the variable names don’t match the table names.</p>
</section>
<section id="fetching-rows">
<h2>Fetching Rows<a class="headerlink" href="#fetching-rows" title="Link to this heading">¶</a></h2>
<p>To actually execute the query, use the <a class="reference internal" href="funcsql.html#funcsql.fetch" title="funcsql.fetch"><code class="xref py py-func docutils literal notranslate"><span class="pre">funcsql.fetch()</span></code></a> function.</p>
<ol class="arabic simple">
<li><p>Load the tables, assigning them to variables.</p></li>
<li><p>Build the query with references to the table variables. Assign this to a variable.</p></li>
<li><p>Apply the <a class="reference internal" href="funcsql.html#funcsql.fetch" title="funcsql.fetch"><code class="xref py py-func docutils literal notranslate"><span class="pre">funcsql.fetch()</span></code></a> function the query. This is an iterable that returns <a class="reference internal" href="funcsql.html#funcsql.Row" title="funcsql.Row"><code class="xref py py-func docutils literal notranslate"><span class="pre">funcsql.Row()</span></code></a> objects.</p></li>
</ol>
<p>The idea is to be able to to SQL-like processing with minimal overhead.</p>
<p>The result is a sequence of <a class="reference internal" href="funcsql.html#funcsql.Row" title="funcsql.Row"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Row</span></code></a> objects.
These are similar to named tuples.
The attribute names come from the <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> instance, which has parameters of the form <code class="docutils literal notranslate"><span class="pre">name=lambda</span> <span class="pre">cr:...</span></code>.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">names_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;names_table&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">values_tables</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span><span class="s2">&quot;values_table&quot;</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
<span class="n">query</span> <span class="o">=</span> <span class="p">(</span><span class="n">Select</span><span class="o">...</span><span class="p">)</span>

<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">fetch</span><span class="p">(</span><span class="n">query</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">row</span><span class="p">)</span>
</pre></div>
</div>
<p>The idea is the minimize the overheads.
This doesn’t have a database connection.
It doesn’t have any cursor management or locking or commits.
It doesn’t create or require a SQL schema.
It does SQL-like processing on Table-like objects.</p>
</section>
<section id="group-by-and-having">
<h2>Group By and Having<a class="headerlink" href="#group-by-and-having" title="Link to this heading">¶</a></h2>
<p>Here’s an example of a <code class="docutils literal notranslate"><span class="pre">GROUP</span> <span class="pre">BY</span></code> clause:</p>
<div class="highlight-SQL notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="k">group</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="k">key</span><span class="p">,</span><span class="w"> </span><span class="k">sum</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="n">total</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">raw_table</span>
<span class="k">GROUP</span><span class="w"> </span><span class="k">BY</span><span class="w"> </span><span class="k">key</span>
</pre></div>
</div>
<p>Here’s the rewrite to use the <a class="reference internal" href="funcsql.html#funcsql.Select.group_by" title="funcsql.Select.group_by"><code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.Select.group_by()</span></code></a> method to build the grouping.
This also uses a <a class="reference internal" href="funcsql.html#funcsql.Aggregate" title="funcsql.Aggregate"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Aggregate</span></code></a> object that wraps a function, the built-in <code class="xref py py-func docutils literal notranslate"><span class="pre">sum()</span></code>,
and a lambda to compute the parameter values for this function.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">value</span></code> item, specifically, is used to extract the required column from the composite row.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">query</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Select</span><span class="p">(</span>
        <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">group</span><span class="p">,</span>
        <span class="n">value</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">raw</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
        <span class="n">total</span><span class="o">=</span><span class="n">Aggregate</span><span class="p">(</span><span class="nb">sum</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">raw_table</span><span class="p">)</span>
    <span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="s2">&quot;key&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>This has a strange-looking redundancy.
The <code class="docutils literal notranslate"><span class="pre">value=lambda</span></code> creates a value for the <code class="docutils literal notranslate"><span class="pre">total=Aggregate</span></code>.
This can be abbreviated to <code class="docutils literal notranslate"><span class="pre">Aggregate(sum,</span> <span class="pre">value=lambda</span> <span class="pre">c:</span> <span class="pre">c.raw.value)</span></code>.</p>
<p>When parsing SQL, a database engine will make a number of optimizations when working out what a name might refer to.
In contrast, this library works directly in Python; it doesn’t have access to the original variable names, table schema,
or expressions.</p>
<p>Here’s the table used for the above query.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">raw_table</span> <span class="o">=</span> <span class="n">Table</span><span class="p">(</span>
    <span class="s2">&quot;raw_table&quot;</span><span class="p">,</span>
    <span class="p">[</span>
        <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">},</span>
        <span class="p">{</span><span class="s2">&quot;group&quot;</span><span class="p">:</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;value&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">},</span>
    <span class="p">],</span>
<span class="p">)</span>
</pre></div>
</div>
</section>
<section id="subqueries">
<h2>Subqueries<a class="headerlink" href="#subqueries" title="Link to this heading">¶</a></h2>
<p>Here’s an example of a subquery:</p>
<div class="highlight-SQL notranslate"><div class="highlight"><pre><span></span><span class="k">SELECT</span><span class="w"> </span><span class="n">first_name</span>
<span class="k">FROM</span><span class="w"> </span><span class="n">employees</span>
<span class="k">WHERE</span><span class="w"> </span><span class="n">department_id</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="n">department_id</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">departments</span><span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">location_id</span><span class="o">&gt;</span><span class="mi">1500</span>
<span class="p">);</span>
</pre></div>
</div>
<p>Part of the query is the <code class="docutils literal notranslate"><span class="pre">department_id</span></code> set created by the subquery.</p>
<p>Here’s an alternative formulation as pure Python.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">department_ids</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span>
    <span class="n">fetch_all_values</span><span class="p">(</span>
        <span class="n">Select</span><span class="p">(</span><span class="n">department_id</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">departments</span><span class="o">.</span><span class="n">department_id</span><span class="p">)</span>
        <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">departments</span><span class="p">)</span>
        <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="nb">int</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">departments</span><span class="o">.</span><span class="n">location_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1500</span><span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>

<span class="n">c3</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Select</span><span class="p">(</span><span class="n">first_name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">first_name</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">employees</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">employees</span><span class="o">.</span><span class="n">department_id</span> <span class="ow">in</span> <span class="n">department_ids</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Note there are two queries.
This reflects the meaning of the SQL, as well as the syntax.
The queries aren’t syntactically nested.</p>
<p>First, the subquery <code class="docutils literal notranslate"><span class="pre">SELECT</span> <span class="pre">department_id</span> <span class="pre">FROM</span> <span class="pre">departments</span> <span class="pre">...</span></code> is executed to create a set of ids.
Second, the main query executes, using that set of ids.</p>
<p>It’s possible to combine them into a single construct.
This is – after all – pure Python.
The <code class="docutils literal notranslate"><span class="pre">set(...)</span></code> expression that computes the value of <code class="docutils literal notranslate"><span class="pre">department_ids</span></code> can replace the <code class="docutils literal notranslate"><span class="pre">department_ids</span></code> variable in the <code class="docutils literal notranslate"><span class="pre">lambda</span> <span class="pre">c:</span> <span class="pre">c.employees.department_id</span> <span class="pre">in</span> <span class="pre">department_ids</span></code> expression.
The lambda becomes very long, but, the subquery is textually part of the main query, if that’s important for reader comprehension.</p>
<p>In principle, a SQL database might optimize <code class="docutils literal notranslate"><span class="pre">IN</span> <span class="pre">(SELECT</span> <span class="pre">x...)</span></code> to a one-row lookup using an index or something.
Since the Python set does lookups so quickly, it’s often faster to build the set of values, then do set membership tests.</p>
</section>
<section id="the-exists-clause">
<h2>The Exists Clause<a class="headerlink" href="#the-exists-clause" title="Link to this heading">¶</a></h2>
<p>The SQL <code class="docutils literal notranslate"><span class="pre">EXISTS()</span></code> function generally contains a subquery that includes a reference to the containing query.</p>
<p>For example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SELECT</span> <span class="n">e</span><span class="o">.</span><span class="n">last_name</span>
<span class="n">FROM</span> <span class="n">employees</span> <span class="n">e</span>
<span class="n">WHERE</span> <span class="n">EXISTS</span> <span class="p">(</span>
    <span class="n">SELECT</span> <span class="o">*</span> <span class="n">FROM</span> <span class="n">employees</span> <span class="n">b</span>
    <span class="n">WHERE</span> <span class="n">b</span><span class="o">.</span><span class="n">employee_id</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">manager_id</span> <span class="n">AND</span> <span class="n">b</span><span class="o">.</span><span class="n">last_name</span> <span class="o">=</span> <span class="s1">&#39;King&#39;</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The subquery uses <code class="docutils literal notranslate"><span class="pre">e.manager_id</span></code> to refer to a column in a row in the containing query.
Here’s the rewritten query.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">c5</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">Select</span><span class="p">(</span><span class="n">last_name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">c</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">last_name</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">e</span><span class="o">=</span><span class="n">employees</span><span class="p">)</span>
    <span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="k">lambda</span> <span class="n">c</span><span class="p">:</span> <span class="n">exists</span><span class="p">(</span>
            <span class="n">c</span><span class="p">,</span>
            <span class="n">Select</span><span class="p">(</span><span class="n">STAR</span><span class="p">)</span>
            <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">b</span><span class="o">=</span><span class="n">employees</span><span class="p">)</span>
            <span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="k">lambda</span> <span class="n">sq</span><span class="p">:</span> <span class="n">sq</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">employee_id</span> <span class="o">==</span> <span class="n">sq</span><span class="o">.</span><span class="n">e</span><span class="o">.</span><span class="n">manager_id</span> <span class="ow">and</span> <span class="n">sq</span><span class="o">.</span><span class="n">b</span><span class="o">.</span><span class="n">last_name</span> <span class="o">==</span> <span class="s2">&quot;King&quot;</span><span class="p">),</span>
        <span class="p">)</span>
    <span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>An <code class="docutils literal notranslate"><span class="pre">exists()</span></code> function has two parameters:</p>
<ul class="simple">
<li><p>The context; the composite row from the parent query.</p></li>
<li><p>A Query, usually a <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> object.</p></li>
</ul>
<p>Using the given context, the query is evaluated.
All of the tables from the parent query are available in the child query.
Table aliases are absolutely required to disambiguate references.</p>
</section>
<section id="with-clause-and-recursion">
<h2><code class="docutils literal notranslate"><span class="pre">WITH</span></code> clause and Recursion<a class="headerlink" href="#with-clause-and-recursion" title="Link to this heading">¶</a></h2>
<p>We have two choices for creating “common table expressions”:</p>
<ul class="simple">
<li><p>Just like everything else – the <a class="reference internal" href="#with-is-a-querybuilder">With is a QueryBuilder</a> implementation.</p></li>
<li><p><a class="reference internal" href="#the-python-with-statement">The Python with statement</a> implementation.
This comes close to the SQL <code class="docutils literal notranslate"><span class="pre">WITH</span></code> clause, but doesn’t do everything.</p></li>
</ul>
<section id="with-is-a-querybuilder">
<h3>With is a QueryBuilder<a class="headerlink" href="#with-is-a-querybuilder" title="Link to this heading">¶</a></h3>
<p>Here’s a simple example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>
    <span class="n">With</span><span class="p">(</span>
        <span class="n">table_1</span><span class="o">=</span><span class="n">Select</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>
        <span class="n">table_2</span><span class="o">=</span><span class="n">Select</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">query</span><span class="p">(</span><span class="n">Select</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="s2">&quot;table_1&quot;</span><span class="p">,</span> <span class="s2">&quot;table_2&quot;</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The <code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.With</span></code> uses <code class="docutils literal notranslate"><span class="pre">table_name</span> <span class="pre">=</span> <span class="pre">Select</span></code> to match the SQL <code class="docutils literal notranslate"><span class="pre">table_name</span> <span class="pre">AS</span> <span class="pre">(SELECT...)</span></code>.</p>
<p>The <code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.With.query()</span></code> method expects a <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a> object.
The table names are strings, since the tables aren’t part of the global namespace; they’re part of the context of the <code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.With</span></code> object.</p>
<p>We can also write this as follows:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="p">(</span>
    <span class="n">With</span><span class="p">(</span>
        <span class="n">table_1</span><span class="o">=</span><span class="n">Select</span><span class="p">(</span><span class="o">...</span><span class="p">),</span>
        <span class="n">table_2</span><span class="o">=</span><span class="n">Select</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="s2">&quot;table_1&quot;</span><span class="p">,</span> <span class="s2">&quot;table_2&quot;</span><span class="p">))</span>
<span class="p">)</span>
</pre></div>
</div>
<p>The use of the <code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.With.select()</span></code> method more closely parallels the SQL syntax.
Use either the <code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.With.query()</span></code> method with an separate <a class="reference internal" href="funcsql.html#funcsql.Select" title="funcsql.Select"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Select</span></code></a>,
or use the <code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.With.select()</span></code> method.
Don’t use both, and don’t mix-and-match in your application.</p>
</section>
<section id="the-python-with-statement">
<h3>The Python <code class="docutils literal notranslate"><span class="pre">with</span></code> statement<a class="headerlink" href="#the-python-with-statement" title="Link to this heading">¶</a></h3>
<p>The following is really unpleasant, but works:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">contextlib</span> <span class="kn">import</span> <span class="n">nullcontext</span>
<span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">with</span> <span class="n">nullcontext</span><span class="p">(</span>
    <span class="n">fetch_table</span><span class="p">(</span><span class="s2">&quot;the_codes&quot;</span><span class="p">,</span> <span class="n">Select</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">code</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">names</span><span class="p">))</span>
<span class="p">)</span> <span class="k">as</span> <span class="n">the_codes</span><span class="p">:</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">fetch</span><span class="p">(</span><span class="n">Select</span><span class="p">(</span><span class="n">STAR</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">the_codes</span><span class="p">))</span>
</pre></div>
</div>
<p>The complication is a <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> has an internal name, separate from the variable name.
Ideally, they match.</p>
<p>This is more pleasant:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="k">with</span> <span class="n">fetch_table</span><span class="p">(</span><span class="s2">&quot;the_codes&quot;</span><span class="p">,</span> <span class="n">Select</span><span class="p">(</span><span class="n">code</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">code</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">names</span><span class="p">))</span> <span class="k">as</span> <span class="n">the_codes</span><span class="p">:</span>
    <span class="n">rows</span> <span class="o">=</span> <span class="n">fetch</span><span class="p">(</span><span class="n">Select</span><span class="p">(</span><span class="n">STAR</span><span class="p">)</span><span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">the_codes</span><span class="p">))</span>
</pre></div>
</div>
<p>This works because a <code class="docutils literal notranslate"><span class="pre">Table</span></code> is a context manager that does almost nothing.</p>
<p>This doesn’t help specify recursive queries, since they’re actually part of the <code class="docutils literal notranslate"><span class="pre">WITH</span></code> clause that creates the CTE used by the target query.</p>
</section>
<section id="more-on-recursive-query-building">
<h3>More on recursive query building<a class="headerlink" href="#more-on-recursive-query-building" title="Link to this heading">¶</a></h3>
<p>The examples in <a class="reference external" href="https://www.sqlite.org/lang_with.html">https://www.sqlite.org/lang_with.html</a> are particularly good at showing the recursive query technique.</p>
<div class="highlight-SQL notranslate"><div class="highlight"><pre><span></span><span class="k">WITH</span><span class="w"> </span><span class="k">RECURSIVE</span>
<span class="w">  </span><span class="n">works_for_alice</span><span class="p">(</span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="k">AS</span><span class="w"> </span><span class="p">(</span>
<span class="w">    </span><span class="k">VALUES</span><span class="p">(</span><span class="s1">&#39;Alice&#39;</span><span class="p">)</span>
<span class="w">    </span><span class="k">UNION</span>
<span class="w">    </span><span class="k">SELECT</span><span class="w"> </span><span class="n">name</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">org</span><span class="p">,</span><span class="w"> </span><span class="n">works_for_alice</span>
<span class="w">     </span><span class="k">WHERE</span><span class="w"> </span><span class="n">org</span><span class="p">.</span><span class="n">boss</span><span class="o">=</span><span class="n">works_for_alice</span><span class="p">.</span><span class="n">n</span>
<span class="w">  </span><span class="p">)</span>
<span class="k">SELECT</span><span class="w"> </span><span class="k">avg</span><span class="p">(</span><span class="n">height</span><span class="p">)</span><span class="w"> </span><span class="k">FROM</span><span class="w"> </span><span class="n">org</span>
<span class="w"> </span><span class="k">WHERE</span><span class="w"> </span><span class="n">org</span><span class="p">.</span><span class="n">name</span><span class="w"> </span><span class="k">IN</span><span class="w"> </span><span class="n">works_for_alice</span><span class="p">;</span>
</pre></div>
</div>
<p>Is restated as follows:</p>
<div class="highlight-Python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">funcsql</span> <span class="kn">import</span> <span class="o">*</span>

<span class="n">query</span> <span class="o">=</span> <span class="p">(</span>
    <span class="n">With</span><span class="p">(</span>
        <span class="n">under_alice</span><span class="o">=</span><span class="n">Values</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="s2">&quot;Alice&quot;</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">union</span><span class="p">(</span>
            <span class="n">Select</span><span class="p">(</span><span class="n">name</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">under_alice</span><span class="o">.</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="n">org</span><span class="p">)</span>
            <span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">table</span><span class="o">=</span><span class="s2">&quot;under_alice&quot;</span><span class="p">,</span> <span class="n">on_</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="n">cr</span><span class="o">.</span><span class="n">org</span><span class="o">.</span><span class="n">boss</span> <span class="o">==</span> <span class="n">cr</span><span class="o">.</span><span class="n">under_alice</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="p">)</span>
    <span class="p">)</span>
    <span class="o">.</span><span class="n">select</span><span class="p">(</span><span class="n">line</span><span class="o">=</span><span class="k">lambda</span> <span class="n">cr</span><span class="p">:</span> <span class="s2">&quot;..........&quot;</span><span class="p">[:</span> <span class="n">cr</span><span class="o">.</span><span class="n">under_alice</span><span class="o">.</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]</span> <span class="o">+</span> <span class="n">cr</span><span class="o">.</span><span class="n">under_alice</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
    <span class="o">.</span><span class="n">from_</span><span class="p">(</span><span class="s2">&quot;under_alice&quot;</span><span class="p">)</span>
<span class="p">)</span>
</pre></div>
</div>
<p>Note the <code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Values</span></code> object,
which implements the SQL <code class="docutils literal notranslate"><span class="pre">Values</span></code> clause.
The SQL <code class="docutils literal notranslate"><span class="pre">UNION</span></code> becomes a <code class="xref py py-meth docutils literal notranslate"><span class="pre">funcsql.Values.union()</span></code> method in query construction.</p>
<p>A <code class="docutils literal notranslate"><span class="pre">Select()...union(Select()...)</span></code> <strong>outside</strong> the <code class="docutils literal notranslate"><span class="pre">WITH</span></code> context is an ordinary Union.
It’s the same as <code class="docutils literal notranslate"><span class="pre">+</span></code> operator between the
data lists that make up a Table.</p>
<p>In a <code class="docutils literal notranslate"><span class="pre">With(table=Select()...union(Select().from(&quot;table&quot;)...))</span></code> <strong>inside</strong> a <code class="docutils literal notranslate"><span class="pre">WITH</span></code> context, the
union specifies recursive traverssal.
Note that this also uses string table name instead of a <a class="reference internal" href="funcsql.html#funcsql.Table" title="funcsql.Table"><code class="xref py py-class docutils literal notranslate"><span class="pre">funcsql.Table</span></code></a> object.
The <code class="docutils literal notranslate"><span class="pre">&quot;under_alice&quot;</span></code> table is the whole point being of this Common Table Expression.
The recursive query is building this table. It doesn’t really exist until after the recursive query is complete.</p>
</section>
</section>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="Main">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="index.html">Functional SQL</a></h1>








<h3>Navigation</h3>
<p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="concept.html">Concept</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#queries">Queries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#schema-and-tables">Schema and Tables</a></li>
<li class="toctree-l2"><a class="reference internal" href="#fetching-rows">Fetching Rows</a></li>
<li class="toctree-l2"><a class="reference internal" href="#group-by-and-having">Group By and Having</a></li>
<li class="toctree-l2"><a class="reference internal" href="#subqueries">Subqueries</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-exists-clause">The Exists Clause</a></li>
<li class="toctree-l2"><a class="reference internal" href="#with-clause-and-recursion"><code class="docutils literal notranslate"><span class="pre">WITH</span></code> clause and Recursion</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="demo.html">Demonstration Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="components.html">Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="funcsql.html">funcsql Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="notes.html">Notes</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="concept.html" title="previous chapter">Concept</a></li>
      <li>Next: <a href="demo.html" title="next chapter">Demonstration Code</a></li>
  </ul></li>
</ul>
</div>
<search id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</search>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &#169;2024, S.Lott.
      
      |
      Powered by <a href="https://www.sphinx-doc.org/">Sphinx 7.4.7</a>
      &amp; <a href="https://alabaster.readthedocs.io">Alabaster 0.7.16</a>
      
      |
      <a href="_sources/tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>